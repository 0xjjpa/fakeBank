TheM.accounts = (function () {
    var _isLoaded = false;
    var _accounts = [];

    function transactionsdoUpdate(givenParams) {
        //Include dateStart, dateEnd to pull transactions for a specified period
        if (this.isWorking) return this.intPromise;
        var that = [];
        givenParams = givenParams || {};
        //will save.dateStart and.dateEnd on success, so will ignore requests to fetch transactions within this range 
        givenParams.dateStart = givenParams.dateStart || (new Date()).addMinutes(-44640); //past 31 days 
        givenParams.dateEnd = givenParams.dateEnd || new Date();
        this.dateStart = this.dateStart || new Date();
        this.dateEnd = this.dateEnd || new Date();
        this.Requeste.dateStart = givenParams.dateStart;
        this.Requeste.dateEnd = givenParams.dateEnd;
        MergeObjects(that, this);
        //TODO: remove msecToExpiry as it is now filter's job to find out if data has to be fetched of pulled from a cache
        if ((new Date() - this.DTSUpdated) < this.msecToExpiry) return Promise.resolve();
        if (!this.intPromise || ((new Date() - this.DTSUpdated) > this.msecToExpiry)) this.intPromise = new Promise(
            function resolver(resolve, reject) {
                TheM.accounts.account(that.accountID).transactions.isWorking = true;
                myAWS.DoCall('fake_transactions.json', {
                    accountID: that.accountID,
                    dateStart: givenParams.dateStart,
                    dateEnd: givenParams.dateEnd
                }, function (data) {
                    data = JSON.parse(data);
                    if (data && data.length) {
                        DeDupAndAdd(TheM.accounts.account(that.accountID).transactions, data, 'id'); //deduplicate objects based on their IDs
                        TheM.accounts.account(that.accountID).transactions.DTSUpdated = new Date();
                        TheM.accounts.account(that.accountID).transactions.isWorking = false;
                        TheM.accounts.account(that.accountID).transactions.dateStart = TheM.accounts.account(that.accountID).transactions.Requeste.dateStart;
                        TheM.accounts.account(that.accountID).transactions.dateEnd = TheM.accounts.account(that.accountID).transactions.Requeste.dateEnd;
                        TheM.refresh();
                        resolve(data);
                    }
                }, function () {
                    TheM.accounts.account(that.accountID).transactions.isWorking = false;
                    reject({
                        error: true,
                        errorMessage: 'Could not get transactions'
                    })
                });
            }
        );

        return this.intPromise;
    }

    var filter = function (givenParams) {
        //returns a subset of transactions between the two given dates
        //Include dateStart, dateEnd to get transactions for a specified period
        //TODO
        givenParams = givenParams || {};
        givenParams.dateStart = givenParams.dateStart || (new Date()).addMinutes(-14640); //past 31 days 
        givenParams.dateEnd = givenParams.dateEnd || new Date().addMinutes(4640);
        console.log(this.dateStart);
        console.log(this.dateEnd);
        console.log(givenParams.dateStart);
        console.log(givenParams.dateEnd);
        var StartInside = false;
        var EndInside = false;
        if (this.dateStart < givenParams.dateStart) StartInside = true;
        if (this.dateEnd > givenParams.dateEnd) EndInside = true;
        var requestParams;
        if (StartInside && EndInside) console.log('TODO: just show transactions already fetched'); //TODO
        if (StartInside && !EndInside) {
            requestParams.dateStart = this.dateEnd;
            requestParams.dateEnd = givenParams.dateEnd;
        }
        if (!StartInside && EndInside) {
            requestParams.dateStart = givenParams.dateStart;
            requestParams.dateEnd = this.dateStart;
        }
        if (!StartInside && !EndInside) {
            //TODO. filter was asked to give transactions before and after of what is available. Perhaps should do two separate calls for the two periods 
            //Instead, as a workaround, we do one call overlaping existing data
            requestParams.dateStart = givenParams.dateStart;
            requestParams.dateEnd = givenParams.dateEnd;
        }
    }


    var aUpdate = function () {
        if (aUpdate.isWorking) return aUpdate.intPromise;
        if ((new Date() - aUpdate.DTSUpdated) < aUpdate.msecToExpiry) return Promise.resolve();
        if (!aUpdate.intPromise || ((new Date() - aUpdate.DTSUpdated) > aUpdate.msecToExpiry)) aUpdate.intPromise = new Promise(
            function resolver(resolve, reject) {
                aUpdate.isWorking = true;
                myAWS.DoCall('fake_accounts.json', {}, function (data) {;
                    data = JSON.parse(data); //TODO: handle parsing errors.
                    _accounts = data.slice();
                    while (TheM.accounts.pop()) {} //clear the accounts array
                    DeDupAndAdd(TheM.accounts, data); //copy all accounts received into the array
                    for (var i = 0; i < TheM.accounts.length; i++) {
                        TheM.accounts[i].transactions = TheM.accounts[i].transactions || [];
                        TheM.accounts[i].transactions.accountID = TheM.accounts[i].id;
                        TheM.accounts[i].transactions.doUpdate = transactionsdoUpdate;
                        TheM.accounts[i].transactions.filter = filter;
                        TheM.accounts[i].transactions.isWorking = false;
                        TheM.accounts[i].transactions.msecToExpiry = 30000000; //???
                        TheM.accounts[i].transactions.DTSUpdated = new Date('1/1/1980');
                        TheM.accounts[i].transactions.intPromise = null;
                    }
                    aUpdate.DTSUpdated = new Date();
                    _isLoaded = true;
                    aUpdate.isWorking = false;
                    TheM.refresh();
                    resolve(data);
                }, function () {
                    aUpdate.isWorking = false;
                    reject({
                        error: true,
                        errorMessage: 'Could not get accounts'
                    })
                });
            }
        );
        return aUpdate.intPromise;
    }

    aUpdate.isWorking = false;
    aUpdate.msecToExpiry = 300000; //???
    aUpdate.DTSUpdated = new Date('1/1/1980');
    aUpdate.intPromise = null;

    var aSave = function () {
        //saves accounts in the local storage
        var compressed = LZString.compressToUTF16(JSON.stringify(_accounts))
        window.localStorage.setItem(TheM.user.id + 'accounts', compressed);
        return true;
    }

    var aLoad = function () {
        //loads accounts from the local storage
        var uncompressed = window.localStorage.getItem(TheM.user.id + 'accounts');
        if (!uncompressed || uncompressed.length < 1) return false;
        uncompressed = LZString.decompressFromUTF16(uncompressed);
        while (TheM.accounts.pop()) {} //clear the accounts array
        DeDupAndAdd(TheM.accounts, JSON.parse(uncompressed));
        while (_accounts.pop()) {}
        DeDupAndAdd(_accounts, JSON.parse(uncompressed)); //immutable, safe copy of accounts
        return true;
    }

    var resp = [];
    resp.doUpdate = aUpdate;
    resp.doSave = aSave;
    resp.doLoad = aLoad;
    resp.account = function (givenAccountID) {
        //returns a account with a given .id
        for (var i = 0; i < _accounts.length; i++) {
            if (_accounts[i].id) {
                if (_accounts[i].id == givenAccountID) {
                    return _accounts[i];
                }
            }
        }
        return false;
    }

    Object.defineProperty(resp, 'isLoaded', {
        get: function () {
            //TheM.accounts.isLoaded returns true if accounts were feteched from the server. 
            return _isLoaded;
        }
    });
    Object.defineProperty(resp, 'all', {
        get: function () {
            return _accounts;
        }
    });
    return resp;
}());
